.ORIG x3000          ; Устанавливает начальный адрес программы в памяти на 0x3000

; Вывод приглашения к вводу
LEA R0, PROMPT       ; Загрузить адрес строки приглашения в регистр R0
PUTS                 ; Вывести приглашение на экран

; Подготовка к считыванию чисел
LEA R1, NUMBERS      ; Загрузить адрес массива для чисел в R1
LEA R4, CONSTATEXP   ; Загрузить адрес массива для сохранения символов в R4
LD R2, COUNT         ; Загрузить счётчик ввода в R2

; Цикл ввода чисел
READ
  GETC               ; Считать символ с клавиатуры
  OUT                ; Вывести введенный символ
  STR R0, R4, #0     ; Сохранить символ в массиве CONSTATEXP
  ADD R4, R4, #1     ; Увеличить указатель массива
  LD R3, NEG48       ; Загрузить модификатор для преобразования символа в число
  ADD R0, R0, R3     ; Преобразовать символ в число
  STR R0, R1, #0     ; Сохранить число в массиве NUMBERS
  ADD R1, R1, #1     ; Увеличить указатель массива
  ADD R2, R2, #-1    ; Уменьшить счетчик ввода
  BRp READ           ; Повторять до окончания ввода

; Начало сортировки массива чисел
LEA R1, NUMBERS      ; Загрузить адрес массива в R1
LD R2, COUNT         ; Загрузить счетчик
ADD R2, R2, #-1      ; Уменьшить счетчик на 1

; Цикл сортировки (метод пузырька)
SORTLOOP
LD R4, COUNT         ; Загрузить значение COUNT в регистр R4 (общее количество элементов для сортировки)  
ADD R4, R4, #-1      ; Уменьшить значение в R4 на 1, так как последний элемент сортировать не надо
LEA R3, NUMBERS      ; Загрузить адрес массива NUMBERS в регистр R3

INLOOP
LDR R0, R3, #0       ; Загрузить текущий элемент массива в R0
LDR R1, R3, #1       ; Загрузить следующий элемент массива в R1
NOT R5, R1           ; Применить отрицание НЕ к содержимому R1 и сохранить результат в R5
ADD R5, R5, #1       ; Поместить в R5 для получения дополнения до двух (для сложения)
ADD R5, R0, R5       ; Сложить R0 и дополнение R1, результат в R5 (используется для сравнения)
BRn SWAP             ; Если R0 > R1 (R5 отрицательно), перейти к метке SWAP для обмена
STR R1, R3, #0       ; Иначе сохранить R1 на место текущего элемента
STR R0, R3, #1       ; И R0 на место следующего элемента

SWAP
ADD R3, R3, #1       ; Инкремент адреса массива, переход к следующему элементу
ADD R4, R4, #-1      ; Декремент R4, предстоит меньше итераций
BRp INLOOP           ; Если R4 > 0, продолжить цикл SORTLOOP

ADD R2, R2, #-1      ; Декремент R2
BRp SORTLOOP         ; Если R2 > 0, повторить цикл SORTLOOP

; Вывод отсортированных чисел
LD R0, NEWLINE       ; Загрузить символ новой строки
OUT                  ; Вывести новую строку

LEA R1, ORIGINAL     ; Загрузить адрес массива оригинальных символов
LD R2, COUNT         ; Загрузить счетчик

; Цикл вывода оригинальных символов
OUTCONSTATEXP
LDR R0, R1, #0       ; Загружаем в R0 значение из массива ORIGINAL по адресу, указанному в R1
OUT                  ; Выводим значение из R0 на консоль (предполагается, что это значение в ASCII)
ADD R1, R1, #1       ; Увеличиваем указатель на следующий элемент массива
ADD R2, R2, #-1      ; Уменьшаем счётчик количества элементов для вывода
BRp OUTCONSTATEXP    ; Повторяем цикл, если значение R2 все еще положительно (остались элементы для вывода)

; Вывод отсортированных чисел
LD R0, NEWLINE       ; Загрузить символ новой строки
OUT                  ; Вывести новую строку

LEA R1, NUMBERS      ; Загрузить адрес массива отсортированных символов
LD R2, COUNT         ; Загрузить счетчик

; Цикл вывода отсортированных чисел
OUTNUMBERS
LDR R0, R1, #0       ; Загружаем в R0 число для вывода из массива NUMBERS по адресу указателя R1
LD R3, POS48         ; Загружаем в R3 значение 48 (декодирование числа в его ASCII-представление, 
                     ; например, для числа '0' это будет 0x30, для '1' - 0x31, и так далее)
ADD R0, R0, R3       ; Преобразуем числовое значение (0-9) в его ASCII-представление путем добавления 48
OUT                  ; Выводим символ, представленный в R0, на консоль (должно быть число от '0' до '9')
ADD R1, R1, #1       ; Инкрементируем указатель R1, чтобы он указывал на следующее число в массиве
ADD R2, R2, #-1      ; Декрементируем счётчик R2, который отслеживает, сколько чисел осталось вывести
BRp OUTNUMBERS       ; Если в R2 все ещё положительное значение, возвращаемся к началу цикла

HALT                 ; Остановка программы           

; Объявление строк, массивов и констант
PROMPT .STRINGZ "Enter 5 numbers: " 
NUMBERS .BLKW 5      ; Выделение памяти для 5 чисел
ORIGINAL .BLKW 5     ; Выделение памяти для 5 чисел начального массива
CONSTATEXP .BLKW 5   ; Выделение памяти для 5 символов
COUNT .FILL #5       ; Количество чисел для ввода
NEG48 .FILL #-48     ; Модификатор для преобразования символа в число
POS48 .FILL #48      ; Модификатор для преобразования числа в символ
NEWLINE .FILL x000A  ; Символ новой строки
.END
